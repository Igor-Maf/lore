

В этой статье мы рассмотрим, как создавать всплывающие и перекрывающие элементы на React, Angular 1.5 и Angular 2.
Мы рассмотрим примеры создания простого модального окна на каждом из фреймворков.
Весь код в статье написан на typescript. 
Исходный код примеров доступен [на github](https://github.com/rd-dev-ukraine/lore/tree/ui-framework-popup/ui-framework-popup)

# Введение 

Что такое "всплывающие и перекрывающие" элементы? 
Это эмуляция при помощи DOM элементов всплывающих окон (в том числе модальных), выпадающих списков и менюшек, панелек для выбора даты и так далее.

Как правило, для таких элементов применяют абсолютное позиционирование в координатах окна (для модальных окон) при помощи `position: fixed`,
или абсолютное позиционирование в координатах родительских элементов - для меню, выпадающих списков и др. - при помощи `position: absolute`.

Простое размещение всплывающих элеменов возле "родителей" и скрытие/отображение их не работает.
Причина - это родительские контейнеры с `overflow`, отличным от `visible`. 
Все, что выступает за границы контейнера, будет обрезано. 

По-хорошему, эту проблему элегантно мог бы решить Shadow DOM, но пока он не готов.
Поэтому DOM элементы для всплывающих компонентов нужно помещать в `body`, ну или, на худой конец, поближе к нему, в специальный контейнер, у родителей которого заведомо нет "обрезающих" стилей.

# Примеры 

Все примеры содержат одинаковую верстку, и состоят из поля ввода с текстом и кнопки.
По нажатию на кнопку введенный текст появляется в "модальном" окошке с кнопкой "Закрыть".

Все примеры написаны на typescript.
Для компиляции и бандлинга используется webpack.
Чтобы запустить примеры, у вас должен быть установлен NodeJS.

Для запуска перейдите в папку с соответствующим примером и выполните в командной строке NodeJS один раз `npm run prepare`, 
чтобы установить глобальные и локальные пакеты. 
Потом выполните `npm run server`.
После этого откройте в браузере адрес [http://localhost:8080](http://localhost:8080)

Если это делать лень, можно просто открыть в браузере `index.html`.

# Angular 1.5

## Компоненты

Начнем мы со старого доброго Angular 1. 
В версии 1.5 Angular приобрел синтаксический сахар в виде метода `component`, который позволяет создавать компоненты. 
Компоненты это на самом деле директивы, но код их объявления больше ориентирован на создание кирпичиков предметной области приложения,
тогда как директивы больше ориентированы на императивную работу с DOM.
Это нововведение простое, но прикольное, и позволяет объявлять компоненты способом, схожим с Angular 2.
Никаких новых фич, которых не было в директивах, этот способ не привносит, 
но может кардинально повлиять на структуру приложения, особенно, 
если раньше вы пользовались `<div ng-controller="MyController as $c">...</div>`.

От себя я могу добавить, что я пользовался этой возможностью в одном из приложений, и был от нее в восторге. 
Она позволяет создавать компоненты с четким контрактом и высоким потенциалом для повторного использования.
Более того, с этой возможностью я отказался от вынесения HTML разметки компонента в отдельный файл, 
т.к. разметка получается маленькая и аккуратная, и не загромождает исходник компонента. 

В примере я тоже использую эту возможность, поэтому, если вы еще не знакомы с ней, 
почитать можно [здесь](https://docs.angularjs.org/guide/component).

## Динамическая загрузка компонентов

Итак, что нужно для показа модального окна? Во-первых, нужно его динамически создать. Во-вторых, нужно добавить его в `body`.

Для динамической загрузки компонентов используется сервис `$compile`. 
Вот его [документация](https://docs.angularjs.org/api/ng/service/$compile). 
По ссылке полное руководство по API директив, интересующая нас часть в самом конце. 
Там описано, как использовать `$compile` для динамической загрузки.

Получаем доступ к `$compile`

``` typescript
// popup.service.ts
import * as angular from "angular";


export class PopupService {

    static $inject = ["$compile"];

    constructor(private $compile: angular.ICompileService) { }
}

```

Объявление `static $inject=["$compile"]` эквивалентно следующему Javascript коду:

``` javascript
function PopupService($compile) {
    ...
} 

PopupService.$inject = ["$compile"];
```

`$compile` принимает три аргумента, нас интересует только первый.
Первый аргумент - это строка, содержащая HTML, который будет потом преобразован работающий фрагмент Angular приложения.
В ней можно использовать любые зарегистрированные компоненты из вашего модуля и его зависимостей,
а также любые валидные конструкции Angular - директивы, шаблонные строки и т.п.

Результатом компиляции будет фабрика - функция, которая позволит связать строковый шаблон с любым `$scope`.
Таким образом, задавая шаблон, в нем можно использовать любые поля и методы вашего скоупа.

Например, вот как выглядит код открытия всплывающего окна:

``` typescript
/// test-popup.component.ts

export class TestPopupComponentController {
    static $inject = ["$scope", PopupService.Name];

    text: string = "Open popup with this text";

    constructor(
        private $scope: angular.IScope,
        private popupService: PopupService) {
    }

    openPopup() {
        const template = `<popup-content text="$c.text" ...></popup-content> `
        this.popupService.open(template)(this.$scope);
    }
}

```

Обратите внимание на несколько вещей. 
Во-первых, шаблон содержит компонент `<popup-content></popup-content>`.
Во-вторых, шаблон содержит обращение к полю `text` контроллера: `text="$c.text"`.
`$c` - это алиас контроллера, заданный при объявлении компонента.

`PopupService.open` также возвращает фабрику, позволяющую связать шаблон со `$scope`.
Для того, чтобы связать динамический компонент со `$scope` нашего компонента, 
приходится передавать `$scope` в контроллер.

Вот как выглядит `PopupService.open`:

``` typescript
// popup.service.ts

open(popupContentTemplate: string): ($scope: angular.IScope) => () => void {
    const content = `
            <div class="popup-overlay">
                ${popupContentTemplate}
            </div>
            `;

    return ($scope: angular.IScope) => {
        const element = this.$compile(content)($scope);
        const body = document.body;

        const popupElement = body.appendChild(element[0]);

        return () => {
            body.removeChild(popupElement);
        };
    };
}

```

В нашей функции мы оборачиваем переданный шаблон в разметку модального окна.
Потом компилируем шаблон, получая фабрику динамических компонентов.
Потом вызываем полученную фабрику, передавая `$scope`, и получаем HTML элемент, который можно добавить в любое место документа.

Хотя наш метод тоже возвращает фабрику для связи с `$scope`, он делает дополнительную работу.
Во-первых, когда фабрика вызывается, он не только создает элемент, но и добавляет его в `body`.
Во-вторых, фабрика создает функцию, которая позволит "закрыть" поп-ап окно, удалив его из документа.
Эту функцию закрытия фабрика и возвращает.

## Вывод

Что ж, вариант не так плох. 
Хотя само отображение окна императивное, тем не менее, содержимое окна все еще реактивно, 
и может быть декларативно связано с родительским `$scope`.
Хотя для отображения контента приходится использовать строки, но если сам контент окна сделать в виде компонента,
то связывать нужно будет только input и output свойства, а не весь контент.
Метод позволяет поместить поп-ап элемент в любое место документа, даже если оно вне `ng-app`.