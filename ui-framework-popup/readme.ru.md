

В этой статье мы рассмотрим, как создавать всплывающие и перекрывающие элементы на React, Angular 1.5 и Angular 2.
Мы рассмотрим примеры создания простого модального окна на каждом из фреймворков.
Весь код в статье написан на typescript. 
Исходный код примеров доступен [на github](https://github.com/rd-dev-ukraine/lore/tree/ui-framework-popup/ui-framework-popup)

# Введение 

Что такое "всплывающие и перекрывающие" элементы? 
Это эмуляция при помощи DOM элементов всплывающих окон (в том числе модальных), выпадающих списков и менюшек, панелек для выбора даты и так далее.

Как правило, для таких элементов применяют абсолютное позиционирование в координатах окна (для модальных окон) при помощи `position: fixed`,
или абсолютное позиционирование в координатах родительских элементов - для меню, выпадающих списков и др. - при помощи `position: absolute`.

Простое размещение всплывающих элеменов возле "родителей" и скрытие/отображение их не работает.
Причина - это родительские контейнеры с `overflow`, отличным от `visible`. 
Все, что выступает за границы контейнера, будет обрезано. 

По-хорошему, эту проблему элегантно мог бы решить Shadow DOM, но пока он не готов.
Поэтому DOM элементы для всплывающих компонентов нужно помещать в `body`, ну или, на худой конец, поближе к нему, в специальный контейнер, у родителей которого заведомо нет "обрезающих" стилей.

# Примеры 

Все примеры содержат одинаковую верстку, и состоят из поля ввода с текстом и кнопки.
По нажатию на кнопку введенный текст появляется в "модальном" окошке с кнопкой "Закрыть".

Все примеры написаны на typescript.
Для компиляции и бандлинга используется webpack.
Чтобы запустить примеры, у вас должен быть установлен NodeJS.

Для запуска перейдите в папку с соответствующим примером и выполните в командной строке NodeJS один раз `npm run prepare`, 
чтобы установить глобальные и локальные пакеты. 
Потом выполните `npm run server`.
После этого откройте в браузере адрес [http://localhost:8080](http://localhost:8080)

Если это делать лень, можно просто открыть в браузере `index.html`.

# Angular 1.5

## Компоненты

Начнем мы со старого доброго Angular 1. 
В версии 1.5 Angular приобрел синтаксический сахар в виде метода `component`, который позволяет создавать компоненты. 
Компоненты это на самом деле директивы, но код их объявления больше ориентирован на создание кирпичиков предметной области приложения,
тогда как директивы больше ориентированы на императивную работу с DOM.
Это нововведение простое, но прикольное, и позволяет объявлять компоненты способом, схожим с Angular 2.
Никаких новых фич, которых не было в директивах, этот способ не привносит, 
но может кардинально повлиять на структуру приложения, особенно, 
если раньше вы пользовались `<div ng-controller="MyController as $c">...</div>`.

От себя я могу добавить, что я пользовался этой возможностью в одном из приложений, и был от нее в восторге. 
Она позволяет создавать компоненты с четким контрактом и высоким потенциалом для повторного использования.
Более того, с этой возможностью я отказался от вынесения HTML разметки компонента в отдельный файл, 
т.к. разметка получается маленькая и аккуратная, и не загромождает исходник компонента. 

В примере я тоже использую эту возможность, поэтому, если вы еще не знакомы с ней, 
почитать можно [здесь](https://docs.angularjs.org/guide/component).

## Динамическая загрузка компонентов

Итак, что нужно для показа модального окна? Во-первых, нужно его динамически создать. Во-вторых, нужно добавить его в `body`.

Для динамической загрузки компонентов используется сервис `$compile`. 
Вот его [документация](https://docs.angularjs.org/api/ng/service/$compile). 
По ссылке полное руководство по API директив, интересующая нас часть в самом конце. 
Там описано, как использовать `$compile` для динамической загрузки.

Получаем доступ к `$compile`

``` typescript
// popup.service.ts
import * as angular from "angular";


export class PopupService {

    static $inject = ["$compile"];

    constructor(private $compile: angular.ICompileService) { }
}

```

Объявление `static $inject=["$compile"]` эквивалентно следующему Javascript коду:

``` javascript
function PopupService($compile) {
    ...
} 

PopupService.$inject = ["$compile"];
```

`$compile` принимает три аргумента, нас интересует только первый.
Первый аргумент - это строка, содержащая HTML, который будет потом преобразован работающий фрагмент Angular приложения.
В ней можно использовать любые зарегистрированные компоненты из вашего модуля и его зависимостей,
а также любые валидные конструкции Angular - директивы, шаблонные строки и т.п.

Результатом компиляции будет фабрика - функция, которая позволит связать строковый шаблон с любым `$scope`.
Таким образом, задавая шаблон, в нем можно использовать любые поля и методы вашего скоупа.

Например, вот как выглядит код открытия всплывающего окна:

``` typescript
/// test-popup.component.ts

export class TestPopupComponentController {
    static $inject = ["$scope", PopupService.Name];

    text: string = "Open popup with this text";

    constructor(
        private $scope: angular.IScope,
        private popupService: PopupService) {
    }

    openPopup() {
        const template = `<popup-content text="$c.text" ...></popup-content> `
        this.popupService.open(template)(this.$scope);
    }
}

```

Обратите внимание на несколько вещей. 
Во-первых, шаблон содержит компонент `<popup-content></popup-content>`.
Во-вторых, шаблон содержит обращение к полю `text` контроллера: `text="$c.text"`.
`$c` - это алиас контроллера, заданный при объявлении компонента.

`PopupService.open` также возвращает фабрику, позволяющую связать шаблон со `$scope`.
Для того, чтобы связать динамический компонент со `$scope` нашего компонента, 
приходится передавать `$scope` в контроллер.

Вот как выглядит `PopupService.open`:

``` typescript
// popup.service.ts

open(popupContentTemplate: string): ($scope: angular.IScope) => () => void {
    const content = `
            <div class="popup-overlay">
                ${popupContentTemplate}
            </div>
            `;

    return ($scope: angular.IScope) => {
        const element = this.$compile(content)($scope);
        const body = document.body;

        const popupElement = body.appendChild(element[0]);

        return () => {
            body.removeChild(popupElement);
        };
    };
}

```

В нашей функции мы оборачиваем переданный шаблон в разметку модального окна.
Потом компилируем шаблон, получая фабрику динамических компонентов.
Потом вызываем полученную фабрику, передавая `$scope`, и получаем HTML элемент, который можно добавить в любое место документа.

Хотя наш метод тоже возвращает фабрику для связи с `$scope`, он делает дополнительную работу.
Во-первых, когда фабрика вызывается, он не только создает элемент, но и добавляет его в `body`.
Во-вторых, фабрика создает функцию, которая позволит "закрыть" поп-ап окно, удалив его из документа.
Эту функцию закрытия фабрика и возвращает.

## Вывод

Что ж, вариант не так плох. 
Хотя само отображение окна императивное, тем не менее, содержимое окна все еще реактивно, 
и может быть декларативно связано с родительским `$scope`.
Хотя для отображения контента приходится использовать строки, но если сам контент окна сделать в виде компонента,
то связывать нужно будет только input и output свойства, а не весь контент.
Метод позволяет поместить поп-ап элемент в любое место документа, даже если оно вне `ng-app`.


# Angular 2

Новая версия Angular, отличающаяся от первого настолько, что, фактически, это новый продукт.
Мои впечатления от него двоякие.

С одной стороны, код компонентов несомненно чище и яснее. 
При написании бизнес-компонентов разделение кода и представления отличное, 
change tracking работает прекрасно, прощайте `$watch` и `$apply`, прекрасные средства для описания контракта компонента.

С другой стороны не оставляет ощущение монструозности. 
[5 min quickstart](https://angular.io/docs/ts/latest/quickstart.html) выглядит издевательством.
Множество дополнительных библиотек, многие из которых обязательны к использованию (как `rxjs`).
То, что я успеваю увидеть надпись **Loading...** при открытии документа *с файловой системы*, вселяет сомнения в его скорости.
Размер бандла в 4.3MB против 1.3MB у Angular 1 и 700KB React (правда, это без оптимизаций, дефолтный бандлинг webpack-а).
(Напоминаю, что webpack собирает (бандлит) весь код приложения и его зависимостей (из npm) в один большой javascript файл).

Кроме того, Angular 2 на момент написания еще RC. 
Код практически готов, багов вроде бы нет, основые вещи сделаны (ну кроме разве что переделки форм).
Однако документация неполная, многие вещи приходится искать в комментариях к github issue 
(как, например, динамическая загрузка компонентов, что, собственно, и подтолкнуло меня к написанию этой статьи).

## Disclaimer

Тратить полтора часа на шаги, описанные в упомянутом 5 min quickstart, не хотелось, 
поэтому проект сконфигурирован не совсем, кхм, традиционно для Angular 2.
SystemJS не используется, вместо этого бандлится webpack-ом.
Причем Angular 2 не указывается как externals, а берется из npm пакета как есть.
В результате получается гигантский бандл в 4.5MB весом.
Поэтому не используйте эту конфигурацию в продакшене, 
если, конечно, не хотите, чтобы пользователи возненавидели ваш индикатор загрузки.
Вторая странность, которая не знаю, чем вызвана, это отличающиеся названия модулей.
Во всех примерах (в том числе в официальной документации) импорт Angular выглядит как ` import { } from "@angular/core"`.
В то же время, у меня так не заработало, а работает `import {} from "angular2/core"`.


## Динамическая загрузка 

К чести Angular 2, код динамической загрузки вызывает трудности только при поиске.
Для динамической загрузки используется класс [ComponentResolver](https://angular.io/docs/ts/latest/api/core/index/ComponentResolver-class.html) в сочетании с [ViewContainerRef](https://angular.io/docs/ts/latest/api/core/index/ViewContainerRef-class.html).

``` typescript

// Асинхронно создает новый компонент по типу.
// Тип - это класс компонена (ну или его функция-конструктор)
 loadComponentDynamically(componentType: Type, container: ViewContainerRef) {
    this.componentResolve
        .resolveComponent(componentType)
        .then(factory => container.createComponent(factory))
        .then(componentRef => {
            // Получаем доступ к экземпляру класса компонента
            componentRef.instance;
            // Получаем доступ ElementRef контейнера, в который помещен компонент
            componentRef.location;
            // Получаем доступ к DOM элементу. 
            componentRef.location.nativeElement;
            // Удаляем компонент
            componentRef.destroy();
        });
 }
```

`ComponentResolver` легко получить через dependency injection. 
`ViewContainerRef`, по-видимому, не может быть создан для произвольного DOM элемента, 
и может быть только получен через dependency injection для существующего Angular компонента.
Это значит, что поместить динамически созданный элемент в произвольное место DOM дерева *невозможно*,
по крайней мере, в релиз-кандидате.

Поэтому, наш механизм для показа поп-апов будет составным. 

Во-первых, у нас будет компонент, в который будут динамически добавляться поп-ап элементы.
Его нужно будет разместить где-нибудь в дереве компонентов, желательно поближе к корневому элементу.
Кроме того, никакой из его родительских контейнеров не должен содержать стилей, обрезающих содержимое.
В коде это `overlay-host.component.ts`. 

Во-вторых, у нас есть вспомогательный компонент, содержащий в себе разметку для окна.
Это `OverlayComponent`, в который оборачивается динамически создаваемый компонент.

В-третьих, у нас есть сервис, который обеспечивает связь между хост-компонентом для поп-апов и
клиентами, которые хотят показывать компонент. 
Сервис достаточно простой, хост-компонент регистрирует себя в нем при создании, 
и метод сервиса просто перенаправляет вызовы открытия окна этому хост-компоненту.

## Хост-компонент

Я приведу класс целиком, он не очень большой, и потом пройдусь по тонким местам:

``` typescript
import { Component, ComponentRef, ComponentResolver, OnInit, Type, ViewChild, ViewContainerRef } from "angular2/core";

import { OverlayComponent } from "./overlay.component";
import { IOverlayHost, OverlayService } from "./overlay.service";

@Component({
    selector: "overlay-host",
    template: "<template #container></template>"
})
export class OverlayHostComponent implements IOverlayHost, OnInit {

    @ViewChild("container", { read: ViewContainerRef }) container: ViewContainerRef;

    constructor(
        private overlayService: OverlayService,
        private componentResolver: ComponentResolver) {
    }

    openComponentInPopup<T>(componentType: Type): Promise<ComponentRef> {
        return this.componentResolver
            .resolveComponent(OverlayComponent)
            .then(factory => this.container.createComponent(factory))
            .then((overlayRef: ComponentRef) => {

                return overlayRef.instance
                    .addComponent(componentType)
                    .then(result => {

                        result.onDestroy(() => {
                            overlayRef.destroy();
                        });

                        const overlay = overlayRef.location.nativeElement;
                        return result;
                    });
            });
    }

    ngOnInit(): void {
        this.overlayService.registerHost(this);
    }
}
```

Первое, на что нужно обратить внимание, это как получается `ViewContainerRef` при помощи запроса к содержимому.
Декоратор `@ViewChild()` позволяет получать `ViewContainerRef` по имени template variable `template: <template #container></template>`.
`#container` - это и есть template variable, переменная шаблона. 
К ней можно обращаться по имени, но только в самом шаблоне.
Чтобы получить доступ к ней из класса компонента, используется упомянутый декоратор. 

Честно говоря, я это нагуглил, и как по мне, это вообще неинтуитивно.
Это одна из особенностей второго Angular-а, которая мне очень сильно бросилась в глаза, - 
в документации очень сложно, или же вообще невозможно, найти решения для типовых задач.
Документация для создания именно бизнес-компонентов нормальная, да и ничего там особо сложного нет.
Однако для сценариев написания контролов, низкоуровненвых компонентов (то, что было директивами в первом),
невозможно найти документации. 
Динамическое создание компонентов, взаимодействие с шаблоном из класса - эти области просто не документированы.
Даже в описании [@ViewChild](https://angular.io/docs/ts/latest/api/core/index/ViewChild-var.html) ничего не сказано
о втором параметре.